## 1.html语义化
1.使我们的代码更加结构化，更加方便阅读，便于开发和维护
2.便于搜素引擎的识别，有利于seo
3.即使在弱网情况下，文档仍可以以一定的文档格式展现出来

## 2.再举几个例子
1.ul 无序列表
2.ol 有序列表 里面li写列表项
3.h1 - h5 分级标题
4.main 页面主要内容（一般一个页面只使用一次，一般用main包围主要功能）
5.header 用于定义页面顶部内容，包括搜索栏，logo等
6.nav 用于定义导航链接
7.article 用于定义文章内容
8.section 用于定义文档中主要内容
9.aside 侧边栏
10.footer 用于定义文档底部内容

## SEO
跟豆瓣学 SEO
首页一定要有一个 H1 标签，让搜索引擎知道网站的核心关键字是什么，豆瓣创造性的把 logo 图和 h1 结合到一起了。
内容页，网站名称就不能作为主题了，所以 H1 是书籍电影名称，同时每一个 H2 都重复主题。让搜索引擎知道，这个页面的内容都是跟主题相关的。
![image-20211123165159650](https://i.loli.net/2021/11/23/b7BUPAIfYFjRNn8.png)
![image-20211123165216026](https://i.loli.net/2021/11/23/JNIRmY8Zu1CXpHL.png)

## 块级元素
> 1 独占一行
> 2.可以设置宽高，如果不设置默认为父集宽的的100%
包括：
```
div
ul li
ol li
h1-h6
dl dt dd
p
form
hr
table
thead
tbody
th
tr
td
```
## 行内元素
> 1.与其他行内元素并排。
> 2.不能设置宽高，默认宽度就是文字宽度。

包括：
```
span
var
strong
cite
em
i
b
a
textarea
small
br
```
## 行内元素/块级元素有哪些？
```
行内：<a>、<b>、<span>、<img>、<input>、<select>...
块级：<div> <ul> <ol> <li> <dl> <dt> <dd> <h1> .. <h6> <p>
```
块级元素和行内元素的区别：
1. 块级元素独占一行，块级元素内可嵌套部分块级元素，而行内元素不能嵌套块级元素
2. 块级元素可设置 margin、padding，但是行内元素只有 margin-left/right 和 padding-left/right 有效
3. 块级 display:block；行内：display:inline（行内块：display: inline-block）
## inline-block
inline-block 的元素（如input、img)既具有 block 元素可以设置宽高的特性，同时又具有 inline 元素默认不换行的特性。当然不仅仅是这些特性，
比如 inline-block 元素也可以设置 vertical-align（因为这个垂直对齐属性只对设置了inline-block的元素有效） 属性。
```
img
input
```
使用inline-block时候就是会有间隙产生，去除方法有两个。
1.直接设置margin-left:-number;
2.父集设置：word-spacing:-number;
## 页面跳转的几种方法

1.
```javascript
window.location.replace("www.baidu.com")
```
2.
```javascript
window.location.href = 'www.baudu.com'
```
3.
```javascript
window.history.go(-1)   //返回上一页
window.history.go(-2)   //返回上两页
window.history.go("www.baudu.com") //跳转
```
4.
```javascript
window.history.back()   // 返回上一页
```
5.
```javascript
window.history.forward()   //返回下一页
```
6.meta
```html
<meta charset="utf-8" http-equiv="refresh" content="3;url=www.baidu.com"> //3秒后跳转到baidu
```

## h5字体不局中，有时候会被切掉一块
当我们写h5时候，加上了line-height和height一致，
但是还是会碰到andriod 有的机型，如有overflow：hidden会是被切掉头部一两个像素情况
设置line-height 也不生效
解决：
display:flex;
align-items:center; 或 align-items:baseline;
## 固定定位布局键盘挡住输入框内容？
```html
<div class="submit">
     <button type="button" class="btn">提交信息</button>
</div>

.submit {
    display: flex;
    width: 100%;
    justify-content: center;
    position: fixed;
    bottom: 0;
}
```
通过resize函数监听窗口变化，然后把fixed属性改为static即可解决
```javascript
var windheight = $(window).height();  /*未唤起键盘时当前窗口高度*/
$(window).resize(function(){
   var docheight = $(window).height();  /*唤起键盘时当前窗口高度*/        
   if(docheight < windheight){            /*当唤起键盘高度小于未唤起键盘高度时执行*/
      $(".submit").css("position","static");
   }else{
      $(".submit").css("position","fixed");
   }           
});
```
## 1px 像素起因
原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：
```javascript
// 设备像素比
window.devicePixelRatio = 设备的物理像素 / CSS像素
```
## 2.用图片代替边框
```css
border: 1px solid transparent;
border-image: url('xxx.jpg') 2 repeat;
```
虽然解决问题了，但是后期样式调整会让人奔溃，比如颜色调整得UI小伙伴重新上传图片，然后又要修改代码，或者直接文件替换有涉及到图片缓存问题，如果后期来了一个要有边框圆角需求完全没法搞。
## 3.background渐变
```css
background-position: left top;
background-image: -webkit-gradient(linear,left bottom,left top,color-stop(0.5,transparent),color-stop(0.5,#e0e0e0),to(#e0e0e0));
```
代码多，展示的边框实际是在原本的border空间内部的，如果元素背景色有变化的样式, 边框线也会消失；最后也不能适应圆角样式。
## 4.box-shadow模拟边框实现
```css
box-shadow: 0  -1px 1px -1px #e5e5e5,   //上边线
            1px  0  1px -1px #e5e5e5,   //右边线
            0  1px  1px -1px #e5e5e5,   //下边线
            -1px 0  1px -1px #e5e5e5;   //左边线
```
毕竟展示的阴影和边框一个样，但如果有边框还要有虚影样式就没法搞，鱼和熊掌不可兼得。
## 5.伪元素先放大后缩小
这个方法的可行性会更高，兼容性也更好。
实现方式：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。
```css
.scale-1px{
  position: relative;
  border:none;
}
.scale-1px:after{
  content: '';
  position: absolute;
  bottom: 0;
  background: #000;
  width: 100%;
  height: 1px;
  /*核心是利用transform缩放边框*/
  -webkit-transform: scaleY(0.5);
  transform: scaleY(0.5);
  -webkit-transform-origin: 0 0;
  transform-origin: 0 0;
}

// 也可以结合JS代码来判断是否设备像素比是不是2dpr
if(window.devicePixelRatio && devicePixelRatio >= 2){
  document.querySelector('ul').className = 'scale-1px';
}
```
目前大部分移动端UI采用该方案，全机型兼容。
## 6.设置viewport解决问题
利用viewport+rem+js 实现的，边框1px直接写上自动转换。
```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" id="WebViewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
        <title>Document</title>
        <style type="text/css"></style>
    </head>
    <body>
        <script type="text/javascript">
            let viewport = document.querySelector('meta[name=viewport]')
            //下面是根据设备像素设置viewport
            if (window.devicePixelRatio == 1) {
                viewport.setAttribute('content', 'width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no')
            }
            if (window.devicePixelRatio == 2) {
                viewport.setAttribute('content', 'width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no')
            }
            if (window.devicePixelRatio == 3) {
                viewport.setAttribute('content', 'width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no')
            }
            function resize() {
                let width = screen.width > 750 ? '75px' : screen.width / 10 + 'px'
                document.getElementsByTagName('html')[0].style.fontSize = width
            }
            window.onresize = resize
        </script>
    </body>
</html>
```
首先明确一点，就是非高清屏（即基本符合96ppi）上浏览器并不会进行缩放，也就没有“1px”问题
所以部分解决方案中要按需进行css媒体查询，根据设备dpr来区分是否需要解决“1px”问题
0.5px
这个方案原理比较简单，主要是看浏览器是否支持并能准确的显示小数值
该方案兼容性较差，实际可能还是按1px渲染
伪元素 + transform scale
原理分析
border无法直接利用transfrom来缩放，于是通过在元素上原本需要边框的位置添加一个宽或高为1px的伪元素来“冒充”边框，转而对该伪元素整体进行缩放
div::after {
    display: block;
    content: '';
    height: 1px;
    // 通过scale变换，元素整体缩小一半
    transform: scale(.5);	
}

```
伪元素 + 渐变背景色
原理分析
仍然是通过添加伪元素来“冒充”边框，再设置该伪元素背景为透明到有颜色的渐变，利用透明的部分背景使元素整体视觉效果变窄
``` 
div::after {
    display: block;
    content: '';
    height: 1px;
    // 背景一半透明，一半黑色，视觉上缩小一半
    background: linear-gradient(#000 50%, transparent 50%);	
}
## DOCTYPE 的作用？标准模式（严格模式）和 兼容模式（混杂模式）有什么区别？
声明位于 HTML 文档中的第一行，处于标签之前，告知浏览器解析器，需要用声明文档去解析这个文档
-   标准模式的排版和 JS 运行模式是以浏览器支持的最高标准运行
-   兼容模式模式中，页面以宽松向后兼容的方式去显示，模拟老式浏览器的行为以防止站点无法工作


## 参考资料

-   [前端面试-HTML 篇](https://github.com/PDKSophia/blog.io/blob/master/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-HTML%E7%AF%87.md)
